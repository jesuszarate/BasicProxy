import multiprocessing
import re
import sys
import urlparse
from socket import *

# This is how we ask team cymru if the file is malware
import whois as whois

CRLF = "\r\n\r\n"

# Http responses
e_501 = "HTTP/1.0 501 Not Implemented\r\n"
e_400 = "HTTP/1.0 400 Bad Request\r\n"
e_200 = "HTTP/1.0 200 OK\r\n"

close_connection_header = "Connection: close"
no_compressed_encoding = 'Accept-Encoding: gzip;q=0, deflate;q=0' # Header to not allow gzip files

class Proxy:
    def __init__(self, server_port, connection_count):
        self.connection_count = connection_count
        #  Socket initialization to start listening
        self.server_socket = socket(AF_INET, SOCK_STREAM)
        self.server_socket.setsockopt(SOL_SOCKET, SO_REUSEADDR, 1)
        self.server_socket.bind(('', server_port))
        self.server_socket.listen(connection_count)
        print ('Listening on port: ' + str(serverPort))
        print 'Press Ctrl + C to stop proxy server.'
        print 'Ready to receive...'

    def run(self):
        while 1:
            try:
                try:
                    connectionSocket, addr = self.server_socket.accept()

                    # Everytime a connection is made fire off a new thread with the socket connection from above
                    # The target is the function that we call in a different thread, and args of course are the parameters
                    # that the function takes.
                    p = multiprocessing.Process(target=self.connection, args=(connectionSocket,))
                    p.start()
                    print 'Process started.'
                    connectionSocket.close()
                except KeyboardInterrupt:
                    print "Bye"
                    break
            except:
                print 'Unable to connect'

    ##
    # This establishes the communication with the client
    ##
    def connection(self, connectionSocket):

        try:
            message = connectionSocket.recv(1024).decode()
            print('Message received.\n')


            # Check for proper format
            # Split by line
            requestParams = message.split("\r\n")

            complete_headers = message.endswith("\r\n\r\n")

            # Split by space in order to get the separation mentioned above
            url_host = requestParams[0].split()

            requestParams.pop(0)

            # Make sure it's in the following format <METHOD> <URL> <HTTP VERSION>
            status = self.check_format(url_host)
            if status[0]:

                if len(url_host) == 3:
                    data = self.GET(connectionSocket, url_host[1], url_host[2], requestParams, complete_headers)
                    connectionSocket.send(data)

            else:
                connectionSocket.send(status[1].encode())

            self.close_socket(connectionSocket)

        except UnicodeDecodeError:
            connectionSocket.send(e_400)
            self.close_socket(connectionSocket)


    ##
    # Makes the get request
    ##
    def GET(self, connection_socket, url, http_version, headers, contains_all_headers):
        url = urlparse.urlparse(url)

        # Default it to port 80 and if I find another one just change it.
        port = 80
        host = ''
        path = '/'
        if url.port is not None:
            port = url.port
            print ('Port: ' + str(port))

        # Save the host if it's inside the url otherwise look for it later on.
        if url.hostname is not None and url.hostname is not '':
            host = url.hostname
            print 'Host: ' + host


        if not contains_all_headers:
            host, headers = self.gather_headers(connection_socket, host)
        elif host == '':  # Go look for host if it's not found above
            host = self.find_host(headers)

        if url.path is not None:
            path = url.path

        print host

        try:
            forward_socket = socket(AF_INET, SOCK_STREAM)
            forward_socket.settimeout(0.30)

            forward_socket.connect((host, port))

            # build the get request string along with the headers
            http_version = self.get_request_string(path, http_version, headers)

            print ("Request: " + http_version)

            forward_socket.send(http_version)
            data = (forward_socket.recv(1000000))
            self.close_socket(forward_socket)

            #Should have the data here from the server so go and check to see if it's good.
            file_chunk = self.parse_response(data)

            hash_md5, whoisResponse = whois.checkBytes(file_chunk)

            if file_chunk != '' and self.isMalware(whoisResponse):
                data = e_200 + '\r\n\r\nLooks like this might be malware! Be careful!\r\n\r\n'
        except Exception as e:
            print e
            data = e_400

        return data

    ##
    # Check to see if response says that the file is malware
    ##
    def isMalware(self, response):
        if response.split(' ')[2] != 'NO_DATA\n' or 'NO_DATA' in response:
            return False
        return True


    ##
    # Splits the header from the body of the response.
    ##
    def parse_response(self, data):
        bts = bytes.partition(data, '\r\n\r\n')
        return bts[2]

    ##
    # Builds the get request string
    ##
    def get_request_string(self, path, http_version, headers):
        return "GET %s %s%s %s %s" % \
               (path, http_version, '\r\n', self.generate_header_string(headers), CRLF)

    def find_host(self, header):
        for h in header:
            if self.is_host(h):
                return h
        return ''

    def generate_header_string(self, headers):
        header_str = '  '
        for h in headers:
            if h != '':
                header_str += h + '\r\n'
        if len(header_str) > 0:
            header_str += '\r\n'
        return close_connection_header + CRLF + CRLF


    def checkHeadersForEnd(self, headers):
        end = False
        host = ''
        for h in headers:
            if self.is_host(h):
                host = h
            elif h == '\r\n':
                return True, host, headers
            elif h == '\r\n':
                end = True
        return False, host, headers

    ###
    # If this method finds the host in the headers provided then that will be returned
    # otherwise it will simply return the passed in host
    ###
    def gather_headers(self, connection_socket, host):
        headers = []

        while 1:
            message = connection_socket.recv(1024).decode()

            if self.is_host(message):
                host = message.split(":")[1].strip()
                continue

            if not re.match('[\w]+\s?:\s?[\w\[.]]+', message):

                if message == "\r\n":
                    return host, headers
                else:
                    print e_400
                    return False, e_400

            headers.append(message)

    def close_socket(self, socket_connection):
        print ('Closing socket...')
        socket_connection.close()
        print ('Socket closed!')

    ##
    #  Check to Make sure that this line is the host
    ##
    def is_host(self, message):
        if re.match('Host\s*:\s*(.+)[\\r\\n]*', message):
            return True
        return False

    ##
    # Checks to make sure it's a GET followed by the http version
    ##
    def check_format(self, list):
        if len(list) < 3:
            print e_400 + ": Invalid format\n"
            return False, e_400

        if not re.match('([GET]|[get])', list[0]):
            print e_501
            return False, e_501

        if not re.match('\w+/?\w+', list[2]):
            print e_400
            return False, e_400

        return True, e_200

if __name__ == '__main__':

    connection_count = 100
    if len(sys.argv) <= 1:
        print('Usage : "python proxy.py PORT"\n[PORT : The port you want to connect to]')
        sys.exit(2)

    serverPort = sys.argv[1]

    if not str.isdigit(serverPort):
        print('Error: Port number must be a number')
        sys.exit(2)

    serverPort = int(serverPort)  # Able to listen to 100 ports
    proxy = Proxy(serverPort, 100)
    proxy.run()
