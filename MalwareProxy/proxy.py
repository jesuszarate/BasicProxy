from socket import *
import sys
import re
import urlparse
import multiprocessing

CRLF = "\r\n\r\n"

e_501 = "HTTP/1.0 501 Not Implemented\r\n"
e_400 = "HTTP/1.0 400 Bad Request\r\n"
e_200 = "HTTP/1.0 200 OK\r\n"

close_connection_header = "Connection: close"


class Proxy:
    def __init__(self, server_port, connection_count):
        self.connection_count = connection_count
        #  Socket initialization to start listening
        self.server_socket = socket(AF_INET, SOCK_STREAM)
        self.server_socket.setsockopt(SOL_SOCKET, SO_REUSEADDR, 1)
        self.server_socket.bind(('', server_port))
        self.server_socket.listen(connection_count)
        print ('Listening on port: ' + str(serverPort))
        print 'Ready to receive...'

    def run(self):
        while 1:
            connectionSocket, addr = self.server_socket.accept()
            p = multiprocessing.Process(target=self.connection, args=(connectionSocket,))
            p.start()
            print 'Process started.'
            connectionSocket.close()

    def connection(self, connectionSocket):

        message = connectionSocket.recv(1024).decode()
        print('Message received.\n')

        # Check for proper format
        requestParams = message.split()

        # Make sure it's in the following format <METHOD> <URL> <HTTP VERSION>
        status = self.check_format(requestParams)
        if status[0]:

            if len(requestParams) == 3:
                data = self.GET(connectionSocket, requestParams[1], requestParams[2])
                connectionSocket.send(data)

        else:
            connectionSocket.send(status[1].encode())

        self.close_socket(connectionSocket)

    def GET(self, connection_socket, url, http_version):
        url = urlparse.urlparse(url)

        port = 80
        host = ''
        path = '/'
        if url.port is not None:
            port = url.port
            print ('Port: ' + str(port))

        if url.netloc is not None and url.netloc is not '':
            host = url.netloc
            print 'Host: ' + host

        host, headers = self.gather_headers(connection_socket, host)

        if url.path is not None:
            path = url.path

        print host

        try:
            forward_socket = socket(AF_INET, SOCK_STREAM)
            forward_socket.settimeout(0.30)

            forward_socket.connect((host, port))

            http_version = "GET %s %s %s \n%s %s" % (path, http_version, CRLF, close_connection_header, CRLF)

            print ("http version " + http_version)

            forward_socket.send(http_version)
            data = (forward_socket.recv(1000000))
            self.close_socket(forward_socket)
        except:
            data = e_400

        return data

    def generate_header_string(self, headers):
        header_str = ''
        host = ''
        for h in headers:
            header_str += h + CRLF
        return header_str

    ###
    # If this method finds the host in the headers provided then that will be returned
    # otherwise it will simply return the passed in host
    ###
    def gather_headers(self, connection_socket, host):
        headers = []
        while 1:
            message = connection_socket.recv(1024).decode()

            if re.match('Host\s?:\s?[\w[.]]+', message):
                host = message.split(":")[1].strip()
                continue

            if not re.match('[\w]+\s?:\s?[\w\[.]]+', message):

                if message == "\r\n":
                    return host, headers
                else:
                    print e_400
                    return False, e_400

            headers.append(message)

    def close_socket(self, socket_connection):
        print ('Closing socket...')
        socket_connection.close()
        print ('Socket closed!')

    def check_format(self, list):
        if len(list) < 3:
            print e_400 + ": Invalid format\n"
            return False, e_400

        if not re.match('([GET]|[get])', list[0]):
            print e_501
            return False, e_501

        if not re.match('\w+/?\w+', list[2]):
            print e_400
            return False, e_400

        return True, e_200


if __name__ == '__main__':

    connection_count = 100
    if len(sys.argv) <= 1:
        print('Usage : "python proxy.py PORT"\n[PORT : The port you want to connect to]')
        sys.exit(2)

    serverPort = sys.argv[1]

    if not str.isdigit(serverPort):
        print('Error: Port number must be a number')
        sys.exit(2)

    serverPort = int(serverPort)

    proxy = Proxy(serverPort, 100)
    proxy.run()
