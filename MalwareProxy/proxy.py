import multiprocessing
import re
import sys
import urlparse
from socket import *

import whois as whois

CRLF = "\r\n\r\n"

e_501 = "HTTP/1.0 501 Not Implemented\r\n"
e_400 = "HTTP/1.0 400 Bad Request\r\n"
e_200 = "HTTP/1.0 200 OK\r\n"

close_connection_header = "Connection: close"
##no_compressed_encoding = 'Accept-Encoding: gzip;q=0,deflate;q=0'
#no_compressed_encoding = 'Accept-Encoding: gzip, deflate'
no_compressed_encoding = 'Accept-Encoding: gzip;q=0, deflate;q=0'


class Proxy:
    def __init__(self, server_port, connection_count):
        self.connection_count = connection_count
        #  Socket initialization to start listening
        self.server_socket = socket(AF_INET, SOCK_STREAM)
        self.server_socket.setsockopt(SOL_SOCKET, SO_REUSEADDR, 1)
        self.server_socket.bind(('', server_port))
        self.server_socket.listen(connection_count)
        print ('Listening on port: ' + str(serverPort))
        print 'Press Ctrl + C to stop proxy server.'
        print 'Ready to receive...'

    def run(self):
        while 1:
            try:
                try:
                    connectionSocket, addr = self.server_socket.accept()
                    p = multiprocessing.Process(target=self.connection, args=(connectionSocket,))
                    p.start()
                    print 'Process started.'
                    connectionSocket.close()
                except KeyboardInterrupt:
                    print "Bye"
                    break
            except:
                print 'Unable to connect'

    def connection(self, connectionSocket):

        try:
            message = connectionSocket.recv(1024).decode()
            print('Message received.\n')


            # Check for proper format
            # Split by line
            requestParams = message.split("\r\n")

            complete_headers = message.endswith("\r\n\r\n")

            # Split by space in order to get the separation mentioned above
            url_host = requestParams[0].split()

            requestParams.pop(0)

            # Make sure it's in the following format <METHOD> <URL> <HTTP VERSION>
            status = self.check_format(url_host)
            if status[0]:

                if len(url_host) == 3:
                    data = self.GET(connectionSocket, url_host[1], url_host[2], requestParams, complete_headers)
                    connectionSocket.send(data)

            else:
                connectionSocket.send(status[1].encode())

            self.close_socket(connectionSocket)

        except UnicodeDecodeError:
            connectionSocket.send(e_400)
            self.close_socket(connectionSocket)


    def GET(self, connection_socket, url, http_version, headers, contains_all_headers):
        url = urlparse.urlparse(url)

        port = 80
        host = ''
        path = '/'
        if url.port is not None:
            port = url.port
            print ('Port: ' + str(port))

        # if url.netloc is not None and url.netloc is not '':
        #     host = url.netloc
        #     print 'Host: ' + host

        if url.hostname is not None and url.hostname is not '':
            host = url.hostname
            print 'Host: ' + host


        if not contains_all_headers:
            host, headers = self.gather_headers(connection_socket, host)
        elif host == '':  # Go look for host if it's not found above
            host = self.find_host(headers)

        if url.path is not None:
            path = url.path

        print host

        try:
            forward_socket = socket(AF_INET, SOCK_STREAM)
            forward_socket.settimeout(0.30)

            forward_socket.connect((host, port))
            #forward_socket.connect(('127.0.0.1', port))

            http_version = self.get_request_string(path, http_version, headers)

            print ("Request: " + http_version)

            forward_socket.send(http_version)
            data = (forward_socket.recv(1000000))
            self.close_socket(forward_socket)

            #Should have the data here from the server so go and check to see if it's good.
            file_chunk = self.parse_response(data)

            hash_md5, whoisResponse = whois.checkBytes(file_chunk)
            print whoisResponse
            print 'hash: ' + str(hash_md5)
            print whoisResponse.split(' ')[2]
            if whoisResponse.split(' ')[2] != 'NO_DATA\n':
                data = 'looks like this might be malware! Be careful\n'
        except Exception as e:
            print e
            data = e_400

        return data

    def parse_response(self, data):
        bts = bytes.partition(data, '\r\n\r\n')
        return bts[2]

    def get_request_string(self, path, http_version, headers):
        return "GET %s %s%s %s %s" % \
               (path, http_version, '\r\n', self.generate_header_string(headers), CRLF)

    def find_host(self, header):
        for h in header:
            if self.is_host(h):
                return h
        return ''

    def generate_header_string(self, headers):
        header_str = '  '
        for h in headers:
            if h != '':
                header_str += h + '\r\n'
        if len(header_str) > 0:
            header_str += '\r\n'
        return close_connection_header + CRLF + CRLF
        #no_compressed_encoding + CRLF + \


    def checkHeadersForEnd(self, headers):

        end = False
        host = ''
        for h in headers:
            if self.is_host(h):
                host = h
            # elif end and h == '\r\n':
            elif h == '\r\n':
                return True, host, headers
            elif h == '\r\n':
                end = True
        return False, host, headers

    ###
    # If this method finds the host in the headers provided then that will be returned
    # otherwise it will simply return the passed in host
    ###
    def gather_headers(self, connection_socket, host):
        headers = []

        while 1:
            message = connection_socket.recv(1024).decode()

            if self.is_host(message):
                host = message.split(":")[1].strip()
                continue

            if not re.match('[\w]+\s?:\s?[\w\[.]]+', message):

                if message == "\r\n":
                    return host, headers
                else:
                    print e_400
                    return False, e_400

            headers.append(message)

    def close_socket(self, socket_connection):
        print ('Closing socket...')
        socket_connection.close()
        print ('Socket closed!')

    def is_host(self, message):
        if re.match('Host\s*:\s*(.+)[\\r\\n]*', message):
            return True
        return False

    def check_format(self, list):
        if len(list) < 3:
            print e_400 + ": Invalid format\n"
            return False, e_400

        if not re.match('([GET]|[get])', list[0]):
            print e_501
            return False, e_501

        if not re.match('\w+/?\w+', list[2]):
            print e_400
            return False, e_400

        return True, e_200

if __name__ == '__main__':

    connection_count = 100
    if len(sys.argv) <= 1:
        print('Usage : "python proxy.py PORT"\n[PORT : The port you want to connect to]')
        sys.exit(2)

    serverPort = sys.argv[1]

    if not str.isdigit(serverPort):
        print('Error: Port number must be a number')
        sys.exit(2)

    serverPort = int(serverPort)  # Able to listen to 100 ports
    proxy = Proxy(serverPort, 100)
    proxy.run()
